{
  "concepts": [
    {
      "priority": 181,
      "concept": "Propositional Logic",
      "category": "Logic",
      "definition": "A branch of logic dealing with propositions and their connectives.",
      "syntax": "p, q, ¬p, p ∧ q, p ∨ q, p → q",
      "examples": [
        "If p = 'It is raining', q = 'I carry an umbrella', then p → q means 'If it is raining, then I carry an umbrella.'"
      ],
      "explanation": "Propositional logic forms the basis for reasoning and formal verification in AI and computer science.",
      "tags": ["logic", "formal reasoning"],
      "related": ["Predicate Logic", "Boolean Algebra"]
    },
    {
      "priority": 182,
      "concept": "Predicate Logic",
      "category": "Logic",
      "definition": "An extension of propositional logic that includes quantifiers and predicates.",
      "syntax": "∀x P(x), ∃x Q(x)",
      "examples": [
        "∀x (Human(x) → Mortal(x)) means 'All humans are mortal.'"
      ],
      "explanation": "Predicate logic allows reasoning about objects and their properties, essential in AI knowledge representation.",
      "tags": ["logic", "formal reasoning"],
      "related": ["Propositional Logic", "Quantifiers"]
    },
    {
      "priority": 183,
      "concept": "Quantifiers",
      "category": "Logic",
      "definition": "Symbols that specify the quantity of specimens in the domain of discourse that satisfy an open formula.",
      "syntax": "∀ (for all), ∃ (there exists)",
      "examples": [
        "∀x P(x) means 'P(x) is true for all x.'"
      ],
      "explanation": "Quantifiers are fundamental in predicate logic and formal proofs.",
      "tags": ["logic", "formal reasoning"],
      "related": ["Predicate Logic", "Proof Techniques"]
    },
    {
      "priority": 184,
      "concept": "Logical Connectives",
      "category": "Logic",
      "definition": "Operators that combine or modify propositions: AND, OR, NOT, IMPLIES, IFF.",
      "syntax": "∧, ∨, ¬, →, ↔",
      "examples": [
        "p ∧ q means 'p and q', ¬p means 'not p'."
      ],
      "explanation": "Logical connectives form the building blocks of logical expressions and reasoning.",
      "tags": ["logic", "formal reasoning"],
      "related": ["Propositional Logic", "Boolean Algebra"]
    },
    {
      "priority": 185,
      "concept": "Boolean Algebra",
      "category": "Logic",
      "definition": "An algebraic structure capturing the rules of logical operations.",
      "syntax": "x ∨ y, x ∧ y, ¬x",
      "examples": [
        "x ∨ ¬x = 1 (Law of excluded middle)"
      ],
      "explanation": "Boolean algebra is essential in digital circuits, logic programming, and AI.",
      "tags": ["logic", "algebra"],
      "related": ["Logical Connectives", "Propositional Logic"]
    },
    {
      "priority": 186,
      "concept": "Truth Tables",
      "category": "Logic",
      "definition": "A table showing the truth values of logical expressions for all possible inputs.",
      "syntax": "Enumerate all combinations of truth values for variables",
      "examples": [
        "Truth table for p ∧ q"
      ],
      "explanation": "Truth tables are used to analyze and verify logical expressions.",
      "tags": ["logic", "formal reasoning"],
      "related": ["Logical Connectives", "Boolean Algebra"]
    },
    {
      "priority": 187,
      "concept": "Proof Techniques",
      "category": "Mathematical Reasoning",
      "definition": "Methods to establish the truth of mathematical statements, including direct proof, contradiction, induction.",
      "syntax": "Varies by technique",
      "examples": [
        "Proof by induction to show sum of first n integers"
      ],
      "explanation": "Proof techniques ensure rigor and correctness in mathematics and AI logic.",
      "tags": ["proof", "reasoning"],
      "related": ["Mathematical Induction", "Contradiction"]
    },
    {
      "priority": 188,
      "concept": "Mathematical Induction",
      "category": "Mathematical Reasoning",
      "definition": "A proof technique to show that a statement holds for all natural numbers.",
      "syntax": "Base case + inductive step",
      "examples": [
        "Proving sum of first n natural numbers = n(n+1)/2"
      ],
      "explanation": "Induction is widely used in discrete math, algorithms, and AI correctness proofs.",
      "tags": ["proof", "induction"],
      "related": ["Proof Techniques", "Recursion"]
    },
    {
      "priority": 189,
      "concept": "Contradiction",
      "category": "Mathematical Reasoning",
      "definition": "A proof technique assuming the negation of a statement and deriving a contradiction.",
      "syntax": "Assume ¬P, derive false",
      "examples": [
        "Proof that √2 is irrational"
      ],
      "explanation": "Proof by contradiction is a powerful tool in mathematics and logic.",
      "tags": ["proof", "reasoning"],
      "related": ["Proof Techniques", "Mathematical Induction"]
    },
    {
      "priority": 190,
      "concept": "Recursion",
      "category": "Mathematical Reasoning",
      "definition": "Defining objects in terms of themselves, often with base cases.",
      "syntax": "f(n) = f(n-1) + ...",
      "examples": [
        "Factorial: n! = n × (n-1)!"
      ],
      "explanation": "Recursion is fundamental in algorithms, combinatorics, and AI.",
      "tags": ["recursion", "algorithms"],
      "related": ["Mathematical Induction", "Sequences"]
    },
    {
      "priority": 191,
      "concept": "Sequences",
      "category": "Discrete Mathematics",
      "definition": "Ordered lists of numbers following a pattern.",
      "syntax": "a_n",
      "examples": [
        "Arithmetic sequence: a_n = a_1 + (n-1)d"
      ],
      "explanation": "Sequences are used in series, algorithms, and time series analysis.",
      "tags": ["discrete math", "series"],
      "related": ["Recursion", "Series"]
    },
    {
      "priority": 192,
      "concept": "Series",
      "category": "Discrete Mathematics",
      "definition": "The sum of terms of a sequence.",
      "syntax": "S_n = Σ a_k",
      "examples": [
        "Sum of first n natural numbers"
      ],
      "explanation": "Series are important in analysis, probability, and AI models.",
      "tags": ["discrete math", "summation"],
      "related": ["Sequences", "Summation"]
    },
    {
      "priority": 193,
      "concept": "Summation Notation",
      "category": "Discrete Mathematics",
      "definition": "Compact notation for sums using the sigma symbol.",
      "syntax": "Σ_{k=1}^n a_k",
      "examples": [
        "Σ_{k=1}^5 k = 15"
      ],
      "explanation": "Summation notation simplifies expression of series and sums.",
      "tags": ["discrete math", "notation"],
      "related": ["Series", "Sequences"]
    },
    {
      "priority": 194,
      "concept": "Generating Functions",
      "category": "Combinatorics",
      "definition": "Formal power series whose coefficients encode information about sequences.",
      "syntax": "G(x) = Σ a_n x^n",
      "examples": [
        "Generating function for Fibonacci numbers"
      ],
      "explanation": "Generating functions are powerful tools for counting and solving recurrences.",
      "tags": ["combinatorics", "series"],
      "related": ["Sequences", "Recursion"]
    },
    {
      "priority": 195,
      "concept": "Big-O Notation",
      "category": "Computational Complexity",
      "definition": "A notation to describe the upper bound on the growth rate of functions.",
      "syntax": "f(n) = O(g(n))",
      "examples": [
        "Sorting algorithms: O(n log n)"
      ],
      "explanation": "Big-O is fundamental for analyzing algorithm efficiency and scalability.",
      "tags": ["complexity", "algorithms"],
      "related": ["Computational Complexity", "Algorithm Analysis"]
    },
    {
      "priority": 196,
      "concept": "Computational Complexity",
      "category": "Computational Theory",
      "definition": "The study of resources required for algorithms to solve problems.",
      "syntax": "Time and space complexity",
      "examples": [
        "Sorting algorithms with different time complexities"
      ],
      "explanation": "Understanding complexity guides efficient algorithm design in AI and CS.",
      "tags": ["complexity", "algorithms"],
      "related": ["Big-O Notation", "Algorithm Analysis"]
    },
    {
      "priority": 197,
      "concept": "Algorithm",
      "category": "Computer Science",
      "definition": "A finite sequence of well-defined instructions to solve a problem.",
      "syntax": "Step-by-step procedure",
      "examples": [
        "Binary search algorithm"
      ],
      "explanation": "Algorithms are the foundation of computation and AI.",
      "tags": ["computer science", "algorithms"],
      "related": ["Computational Complexity", "Data Structures"]
    },
    {
      "priority": 198,
      "concept": "Recurrence Relation",
      "category": "Discrete Mathematics",
      "definition": "An equation that defines a sequence recursively.",
      "syntax": "a_n = f(a_{n-1}, a_{n-2}, ...)",
      "examples": [
        "Fibonacci sequence: a_n = a_{n-1} + a_{n-2}"
      ],
      "explanation": "Recurrence relations model sequences and algorithm runtimes.",
      "tags": ["discrete math", "recursion"],
      "related": ["Sequences", "Generating Functions"]
    },
    {
      "priority": 199,
      "concept": "Modular Arithmetic",
      "category": "Number Theory",
      "definition": "Arithmetic system for integers where numbers wrap around upon reaching a certain value (modulus).",
      "syntax": "a ≡ b (mod n)",
      "examples": [
        "17 ≡ 5 (mod 12)"
      ],
      "explanation": "Modular arithmetic is fundamental in cryptography and computer science.",
      "tags": ["number theory", "arithmetic"],
      "related": ["Congruence", "Chinese Remainder Theorem"]
    },
    {
      "priority": 200,
      "concept": "Congruence",
      "category": "Number Theory",
      "definition": "An equivalence relation in modular arithmetic.",
      "syntax": "a ≡ b (mod n)",
      "examples": [
        "23 ≡ 3 (mod 10)"
      ],
      "explanation": "Congruences are used in cryptography and coding theory.",
      "tags": ["number theory", "arithmetic"],
      "related": ["Modular Arithmetic", "Chinese Remainder Theorem"]
    },
    {
      "priority": 201,
      "concept": "Greatest Common Divisor (GCD)",
      "category": "Number Theory",
      "definition": "The largest positive integer dividing two integers without remainder.",
      "syntax": "gcd(a,b)",
      "examples": [
        "gcd(12, 18) = 6"
      ],
      "explanation": "GCD is used in simplifying fractions and cryptographic algorithms.",
      "tags": ["number theory", "arithmetic"],
      "related": ["Euclid's Algorithm", "Least Common Multiple"]
    },
    {
      "priority": 202,
      "concept": "Euclid's Algorithm",
      "category": "Number Theory",
      "definition": "An efficient method to compute the GCD of two integers.",
      "syntax": "gcd(a,b) = gcd(b, a mod b)",
      "examples": [
        "gcd(48,18) computed via repeated modulo"
      ],
      "explanation": "Euclid's algorithm is fundamental in number theory and cryptography.",
      "tags": ["number theory", "algorithm"],
      "related": ["Greatest Common Divisor", "Modular Arithmetic"]
    },
    {
      "priority": 203,
      "concept": "Least Common Multiple (LCM)",
      "category": "Number Theory",
      "definition": "The smallest positive integer divisible by two integers.",
      "syntax": "lcm(a,b) = |a*b| / gcd(a,b)",
      "examples": [
        "lcm(4,6) = 12"
      ],
      "explanation": "LCM is used in fraction addition and scheduling problems.",
      "tags": ["number theory", "arithmetic"],
      "related": ["Greatest Common Divisor", "Modular Arithmetic"]
    },
    {
      "priority": 204,
      "concept": "Prime Numbers",
      "category": "Number Theory",
      "definition": "Natural numbers greater than 1 that have no positive divisors other than 1 and themselves.",
      "syntax": "p is prime if ∀ d | p, d=1 or d=p",
      "examples": [
        "2, 3, 5, 7, 11"
      ],
      "explanation": "Primes are the building blocks of integers and key in cryptography.",
      "tags": ["number theory", "primes"],
      "related": ["Composite Numbers", "Fundamental Theorem of Arithmetic"]
    },
    {
      "priority": 205,
      "concept": "Composite Numbers",
      "category": "Number Theory",
      "definition": "Natural numbers greater than 1 that are not prime.",
      "syntax": "n is composite if ∃ d | n, d ≠ 1, n",
      "examples": [
        "4, 6, 8, 9"
      ],
      "explanation": "Composite numbers have factors other than 1 and themselves.",
      "tags": ["number theory", "composites"],
      "related": ["Prime Numbers", "Factorization"]
    },
    {
      "priority": 206,
      "concept": "Fundamental Theorem of Arithmetic",
      "category": "Number Theory",
      "definition": "Every integer greater than 1 can be uniquely factored into prime numbers.",
      "syntax": "n = p1^a1 * p2^a2 * ... * pk^ak",
      "examples": [
        "60 = 2^2 * 3 * 5"
      ],
      "explanation": "This theorem underpins number theory and cryptography.",
      "tags": ["number theory", "factorization"],
      "related": ["Prime Numbers", "Composite Numbers"]
    },
    {
      "priority": 207,
      "concept": "Modular Inverse",
      "category": "Number Theory",
      "definition": "An integer x such that (a * x) mod n = 1.",
      "syntax": "a * a^{-1} ≡ 1 (mod n)",
      "examples": [
        "Modular inverse of 3 mod 11 is 4"
      ],
      "explanation": "Modular inverses are essential in cryptography and solving modular equations.",
      "tags": ["number theory", "modular arithmetic"],
      "related": ["Modular Arithmetic", "Euclid's Algorithm"]
    },
    {
      "priority": 208,
      "concept": "Chinese Remainder Theorem",
      "category": "Number Theory",
      "definition": "A theorem providing conditions for solving systems of simultaneous congruences with different moduli.",
      "syntax": "x ≡ a_i (mod n_i), with gcd(n_i, n_j) = 1",
      "examples": [
        "Solving x ≡ 2 (mod 3), x ≡ 3 (mod 5)"
      ],
      "explanation": "CRT is used in cryptography, coding theory, and computer algorithms.",
      "tags": ["number theory", "modular arithmetic"],
      "related": ["Modular Arithmetic", "Congruence"]
    },
    {
      "priority": 209,
      "concept": "Fermat's Little Theorem",
      "category": "Number Theory",
      "definition": "If p is prime and a is not divisible by p, then a^{p-1} ≡ 1 (mod p).",
      "syntax": "a^{p-1} ≡ 1 (mod p)",
      "examples": [
        "3^6 ≡ 1 (mod 7)"
      ],
      "explanation": "Used in primality testing and cryptography.",
      "tags": ["number theory", "theorem"],
      "related": ["Modular Arithmetic", "Prime Numbers"]
    },
    {
      "priority": 210,
      "concept": "Euler's Totient Function",
      "category": "Number Theory",
      "definition": "Counts the positive integers up to n that are relatively prime to n.",
      "syntax": "φ(n)",
      "examples": [
        "φ(9) = 6"
      ],
      "explanation": "Used in RSA encryption and number theory.",
      "tags": ["number theory", "function"],
      "related": ["Modular Arithmetic", "Fermat's Little Theorem"]
    },
    {
      "priority": 211,
      "concept": "Graph Coloring",
      "category": "Graph Theory",
      "definition": "Assigning colors to vertices so that no two adjacent vertices share the same color.",
      "syntax": "Color function c: V → {1,2,...,k}",
      "examples": [
        "Coloring a map so neighboring regions have different colors."
      ],
      "explanation": "Graph coloring is used in scheduling, register allocation, and map coloring problems.",
      "tags": ["graph theory", "coloring"],
      "related": ["Graph Theory", "Chromatic Number"]
    },
    {
      "priority": 212,
      "concept": "Chromatic Number",
      "category": "Graph Theory",
      "definition": "The minimum number of colors needed to color a graph.",
      "syntax": "χ(G)",
      "examples": [
        "A bipartite graph has chromatic number 2."
      ],
      "explanation": "Chromatic number measures graph complexity in coloring problems.",
      "tags": ["graph theory", "coloring"],
      "related": ["Graph Coloring", "Graph Theory"]
    },
    {
      "priority": 213,
      "concept": "Hamiltonian Cycle",
      "category": "Graph Theory",
      "definition": "A cycle that visits every vertex exactly once and returns to the starting vertex.",
      "syntax": "Cycle covering all vertices",
      "examples": [
        "Traveling salesman problem route."
      ],
      "explanation": "Hamiltonian cycles are important in optimization and computational complexity.",
      "tags": ["graph theory", "cycles"],
      "related": ["Hamiltonian Path", "Graph Theory"]
    },
    {
      "priority": 214,
      "concept": "Ramsey Theory",
      "category": "Combinatorics",
      "definition": "Study of conditions under which order or structure must appear.",
      "syntax": "R(m,n) is the minimum number of vertices to guarantee a clique or independent set.",
      "examples": [
        "In any group of six people, there are three mutual friends or three mutual strangers."
      ],
      "explanation": "Ramsey theory explores unavoidable patterns in large structures.",
      "tags": ["combinatorics", "theory"],
      "related": ["Combinatorics", "Graph Theory"]
    },
    {
      "priority": 215,
      "concept": "Pigeonhole Principle",
      "category": "Combinatorics",
      "definition": "If n items are put into m containers, with n > m, then at least one container has more than one item.",
      "syntax": "If n > m, then ∃ container with ≥ 2 items",
      "examples": [
        "In a group of 13 people, at least two share a birth month."
      ],
      "explanation": "A fundamental counting principle used in proofs and algorithms.",
      "tags": ["combinatorics", "principle"],
      "related": ["Counting", "Combinatorics"]
    },
    {
      "priority": 216,
      "concept": "Inclusion-Exclusion Principle",
      "category": "Combinatorics",
      "definition": "A formula to calculate the size of the union of overlapping sets.",
      "syntax": "|A ∪ B| = |A| + |B| - |A ∩ B|",
      "examples": [
        "Counting students in overlapping clubs."
      ],
      "explanation": "Used to avoid double-counting in combinatorial problems.",
      "tags": ["combinatorics", "principle"],
      "related": ["Counting", "Set Theory"]
    }
  ]
}
