/**
 * ==========================================================
 * File: /lib/ai-engine/agents/planner-agent/index.ts
 * Project: ZacAI 3.0
 * Role: Multi-Agent System - Planner Agent
 * Description:
 *   - Specializes in decomposing complex user requests into actionable sub-tasks.
 *   - Identifies which other agents (or tools) are best suited for each sub-task.
 *   - Generates a structured plan for the orchestrator to execute.
 * ==========================================================
 */

import { Agent, AgentContext, AgentResponse, registerAgent, listAgents } from '../agent-registry';
import { infer } from '../../engine'; // Core LLM inference
import { generateTraceStep } from '../../explainability'; // Tracing
import { v4 as uuidv4 } from 'uuid'; // For generating unique IDs

/**
 * @interface PlanStep
 * @description Represents a single step in the execution plan.
 */
export interface PlanStep {
  stepId: string;
  task: string; // Description of the task for this step
  assignedAgent?: string; // The name of the agent assigned to this task (if any)
  dependencies: string[]; // stepIds this step depends on
  status?: 'pending' | 'in_progress' | 'completed' | 'failed';
  result?: any; // Output from this step
}

/**
 * @interface ExecutionPlan
 * @description The complete plan generated by the Planner Agent.
 */
export interface ExecutionPlan {
  planId: string;
  originalPrompt: string;
  steps: PlanStep[];
}

class PlannerAgent implements Agent {
  name = 'PlannerAgent';
  description = 'Decomposes complex tasks into smaller steps, identifies suitable agents for each step, and creates a structured execution plan. Ideal for orchestrating multi-agent workflows.';

  /**
   * Determines if the PlannerAgent can handle the given task.
   * It's designed to handle complex, multi-step, or multi-domain tasks.
   * @param task The task description.
   * @param context The agent context.
   * @returns A Promise resolving to true if the agent can handle the task, false otherwise.
   */
  async canHandle(task: string, context: AgentContext): Promise<boolean> {
    generateTraceStep("PlannerAgent CanHandle Check", { task: task.slice(0, 50) + "..." });
    // Use LLM to determine complexity / multi-step nature
    const checkPrompt = `Assess if the following request requires a multi-step plan involving multiple specialized agents. Respond with 'yes' or 'no'.
      User Request: "${task}"
      Context: ${JSON.stringify({
        recentHistory: context.globalMemory?.shortTerm?.sessionHistory?.slice(-1).map(h => h.prompt),
        multimodalSummary: context.multimodalProcessed?.summary
      }).slice(0, 200)}
      
      Response:`;
    try {
      const { text: decision } = await infer(checkPrompt, { context });
      const can = decision.trim().toLowerCase() === 'yes';
      generateTraceStep("PlannerAgent CanHandle Result", { task: task.slice(0, 50) + "...", canHandle: can });
      return can;
    } catch (error) {
      generateTraceStep("PlannerAgent CanHandle Error", { error: (error as Error).message });
      console.error(`[PlannerAgent] Error in canHandle: ${error}`);
      return false; // Default to false on error
    }
  }

  /**
   * Processes the user's request by generating an execution plan.
   * @param task The user's request.
   * @param context The agent context.
   * @returns A Promise resolving to an AgentResponse containing the ExecutionPlan.
   */
  async process(task: string, context: AgentContext): Promise<AgentResponse> {
    generateTraceStep("PlannerAgent Process Started", { task: task.slice(0, 100) + "..." });

    try {
      const availableAgents = listAgents(); // Get all agents registered in the system

      const planningPrompt = `You are a sophisticated AI Planner. Your goal is to create a detailed, step-by-step execution plan to fulfill the user's request. For each step, identify the specific task and assign the most suitable agent from the list of available agents. If no agent is suitable, leave 'assignedAgent' null. If a step has dependencies, list the 'stepId' of its prerequisites.

      User Request: "${task}"
      Available Agents:
      ${availableAgents.map(agent => `- ${agent.name}: ${agent.description}`).join('\n')}
      
      Conversation History: ${context.globalMemory?.shortTerm?.sessionHistory?.slice(-2).map(h => `User: "${h.prompt}"`).join('; ') || 'N/A'}
      
      Respond with a JSON object containing a 'planId' and an array of 'steps'. Each step should have 'stepId' (unique ID for the step), 'task' (description of the sub-task), 'assignedAgent' (name of the agent, or null), and 'dependencies' (an array of stepIds).

      Example JSON structure:
      {
        "planId": "plan-xyz",
        "steps": [
          { "stepId": "step-1", "task": "Understand user intent and context", "assignedAgent": "IntentAgent", "dependencies": [] },
          { "stepId": "step-2", "task": "Generate Python code for a quicksort algorithm", "assignedAgent": "CodeGenerationAgent", "dependencies": ["step-1"] },
          { "stepId": "step-3", "task": "Review and lint the generated Python code for best practices", "assignedAgent": "CodeReviewAgent", "dependencies": ["step-2"] },
          { "stepId": "step-4", "task": "Synthesize final response from all sub-tasks", "assignedAgent": null, "dependencies": ["step-3"] }
        ]
      }
      `;

      const { text: planJson } = await infer(planningPrompt, { context });
      const executionPlan: ExecutionPlan = JSON.parse(planJson);

      // Basic validation of the generated plan
      if (!executionPlan || !executionPlan.planId || !Array.isArray(executionPlan.steps) || executionPlan.steps.length === 0) {
        throw new Error("Invalid plan structure generated by PlannerAgent.");
      }
      executionPlan.originalPrompt = task; // Store original prompt in the plan

      generateTraceStep("PlannerAgent Plan Generated", { planId: executionPlan.planId, stepsCount: executionPlan.steps.length });

      return {
        success: true,
        output: executionPlan,
        agentName: this.name,
        taskSummary: `Generated a ${executionPlan.steps.length}-step plan for the request.`,
      };
    } catch (error: any) {
      generateTraceStep("PlannerAgent Process Error", { error: error.message });
      console.error(`[PlannerAgent] Error processing task: ${error.message}`);
      return {
        success: false,
        output: null,
        agentName: this.name,
        taskSummary: "Failed to generate an execution plan.",
        error: error.message,
      };
    }
  }
}

export const plannerAgent = new PlannerAgent();
// Don't register here; registration will happen in a central init file.
// registerAgent(plannerAgent); // This would be called in a main agent initialization file
